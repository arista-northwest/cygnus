#!/usr/bin/env python

"""
## Command-style:

```
set nexthop-group name CYGNUS_NHG_1 entry 0 nexthop 172.16.130.1 label 30,31,32
set nexthop-group name CYGNUS_NHG_1 entry 1 nexthop 172.16.130.2 label 40,41,42
set route prefix 5.3.0.0/24 via CYGNUS_NHG_1
del route prefix 5.3.0.0/24 via CYGNUS_NHG_1
del route prefix 5.3.0.0/24
del nexthop-group name CYGNUS_NHG_1
```
"""

import json
import re
import socket
import sys
import time

import eossdk

MAX_BUF_SIZE = 4096

def byteify(input):
    if isinstance(input, dict):
        return {byteify(key): byteify(value)
                for key, value in input.iteritems()}
    elif isinstance(input, list):
        return [byteify(element) for element in input]
    elif isinstance(input, unicode):
        return input.encode('utf-8')
    else:
        return input

class ServerHandler(eossdk.FdHandler):
    """Wrapper for FdHandler that accepts multiple client connetions on a TCP
    socket"""
    def __init__(self, address, backlog=5):

        # keep track fo client connections
        self._address = address
        self._backlog = backlog
        self._connections = []
        self._server = None

        eossdk.FdHandler.__init__(self)
        self.acl_mgr = sdk.get_acl_mgr()
        self.vrf_mgr = sdk.get_vrf_mgr()

        self.serve(address, backlog)

    def on_request(self, fd, data):
        """trigger when a request is received on a client connection.  users
        should override this method to handle the data"""
        pass

    def on_connection(self, fd, addr):
        pass

    def serve(self, address, backlog):

        self.tracer.trace0("Opening socket server on %s.%d" % self._address)

        #fd = self.vrf_mgr.socket_at(socket.AF_INET, socket.SOCK_STREAM, 0, vrf="management")
        self._server = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)

        # reuse this socket if in TIME_WAIT state
        self._server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        # set socket to non-blocking. Watch readble will let us know when data
        # is available
        self._server.setblocking(0)

        self._server.bind(self._address)
        self._server.listen(self._backlog)

        self.watch_readable(self._server.fileno(), True);

    def _is_connection_allowed(self, src_addr):
        """Test connection against configure service ACL

        Example:

        ip access-list standard MY_AGENT_ACL
            10 permit 192.168.0.0/16

        daemon MyAgent
            exec /path/to/myagent
            ip access-group MY_AGENT_ACL [in]
            no shutdown

        """

        src_ip, src_port = src_addr
        dst_ip, dst_port = self._server.getsockname()

        src_ip = eossdk.IpAddr(src_ip)
        dst_ip = eossdk.IpAddr(dst_ip)

        if not self.acl_mgr.stream_allowed(src_ip, dst_ip, 0, src_port,
                                           dst_port):
            return False

        return True

    def on_readable(self, fd):
        """React to events on watched sockets. This method handles both new
        connections and data received on existing ones"""

        if fd == self._server.fileno():
            new_fd, src_addr = self._server.accept()

            if not self._is_connection_allowed(src_addr):
                self.tracer.trace1(
                    "Connection from %s blocked by ACL" % src_addr[0])
                new_fd.close()
                return

            new_fd.setblocking(0)

            self._connections.append(new_fd)

            response = self.on_connection(new_fd, src_addr)

            if response:
                new_fd.send(response)

            self.watch_readable(new_fd.fileno(), True)
        else:
            readable = [f for f in self._connections if f.fileno() == fd][0]

            if not readable:
                return

            data = readable.recv(MAX_BUF_SIZE)

            if not data:
                self.watch_readable(fd, False)
                readable.shutdown(2)
                readable.close()
                self._connections.remove(readable)
                return

            response = self.on_request(readable, data)

            if response:
                readable.send(response)

class CygnusAgent(eossdk.AgentHandler, ServerHandler):

    def __init__(self, sdk):
        self.tracer = eossdk.Tracer("CygnusAgent")

        self.agent_mgr = sdk.get_agent_mgr()
        self.nhg_mgr = sdk.get_nexthop_group_mgr()
        self.ip_route_mgr = sdk.get_ip_route_mgr()

        eossdk.AgentHandler.__init__(self, self.agent_mgr)
        ServerHandler.__init__(self, ("0.0.0.0", 6667))

    def _set_nexthop_group(self, name, entries=[]):
        """
        {
            "command": "set",
            "type": "nexthop-group"
            "name": "CYGNUS_NHG_1",
            "entries": [
                {
                    "nexthop": "172.16.130.1",
                    "label": [30, 31, 32]
                },
                {
                    "nexthop": "172.16.130.2",
                    "label": [40, 41, 42]
                }
            ]
        }
        """
        nhg = eossdk.NexthopGroup(name, eossdk.NEXTHOP_GROUP_MPLS)

        for index, entry in enumerate(entries):
            labels = tuple([eossdk.MplsLabel(l) for l in entry["label"]])
            action = eossdk.NexthopGroupMplsAction(
                eossdk.MPLS_ACTION_PUSH,
                labels
            )
            nhe = eossdk.NexthopGroupEntry(eossdk.IpAddr(entry["nexthop"]))
            nhe.mpls_action_is(action)
            nhg.nexthop_set(index, nhe)

        self.nhg_mgr.nexthop_group_set(nhg)

    def _del_nexthop_group(self, name):
        """{
            "command": "del",
            "type": "nexthop-group"
            "name": "CYGNUS_NHG_1"
        }"""
        is_active = self.nhg_mgr.active(name)

        if not is_active:
            self.tracer.trace0("DELETING: Nexthop-group '%s'" % name)
            self.nhg_mgr.nexthop_group_del(name)
        else:
            self.tracer.trace0("NOT-DELETING: NHG '%s' is still active" % name)

    def _set_route(self, prefix, nexthop_group):
        """{
            "command": "set",
            "type": "route",
            "prefix": "5.3.0.0/24",
            "nexthop_group": "CYGNUS_NHG_1"
        }"""
        prefix = eossdk.IpPrefix(str(prefix))
        route_key = eossdk.IpRouteKey(prefix)
        route = eossdk.IpRoute(route_key)
        via = eossdk.IpRouteVia(route_key)
        via.nexthop_group_is(str(nexthop_group))

        self.ip_route_mgr.ip_route_set(route)
        self.ip_route_mgr.ip_route_via_set(via)

    def _del_route(self, prefix, nexthop_group=None):
        """{
            "command": "del",
            "type": "route",
            "prefix": "5.3.0.0/24",
            "nexthop_group": "CYGNUS_NHG_1" // optional
        }"""
        prefix = eossdk.IpPrefix(str(prefix))
        route_key = eossdk.IpRouteKey(prefix)
        route = eossdk.IpRoute(route_key)

        if nexthop_group:
            via = eossdk.IpRouteVia(route_key)
            via.nexthop_group_is(str(nexthop_group))
            self.ip_route_mgr.ip_route_via_del(via)
        else:
            self.ip_route_mgr.ip_route_del(route_key)


    def on_agent_enabled(self, enabled):
        if enabled == False:
            self.agent_mgr.agent_shutdown_complete_is(True)

    def on_initialized(self):
        self.tracer.trace0("cygnus agent initialized...")

    def on_connection(self, fd, addr):
        fd.send("Hello %s, welcome to Cygnus.\n" % addr[0])

    def on_request(self, fd, data):

        if not re.search(r"\w+", data):
            return

        try:
            data = byteify(json.loads(data))
        except ValueError as exc:
            self.tracer.trace0("Data on is not valid JSON")
            fd.send("ERROR: Not valid JSON\n")
            return

        if "command" not in data:
            fd.send("ERROR: No command specified\n")
            return

        if "type" not in data:
            fd.send("ERROR: No type specified\n")
            return

        action = data["command"]
        type = re.sub(r"\-", "_", data["type"])
        params = {k:v for k,v in data.items() if k not in ["command", "type"]}

        func = getattr(self, "_%s_%s" % (action, type))

        func(**params)

if __name__ == "__main__":
    sdk = eossdk.Sdk()
    _ = CygnusAgent(sdk)
    sdk.main_loop(sys.argv)
